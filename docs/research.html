<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.549">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Pratik Mahajan - Research</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">Pratik Mahajan</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="./index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link active" href="./research.html" aria-current="page"> 
<span class="menu-text">Research</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./teaching.html"> 
<span class="menu-text">Teaching</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./data.html"> 
<span class="menu-text">Data</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./public writing.html"> 
<span class="menu-text">Public Writing</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./snapshots.html"> 
<span class="menu-text">Fieldwork</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
          <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-full page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content column-page" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Research</h1>
</div>



<div class="quarto-title-meta column-page">

    
  
    
  </div>
  


</header>


<style>
.abstract-box {
  display: none;
  max-height: 220px;
  overflow-y: auto;
  padding: 10px;
  background-color: #f9f9f9;
  border-left: 4px solid #ccc;
  margin-left: 0.5em;
  font-size: 0.85rem;
  width: 100%;
}
button.abstract-toggle {
  font-size: 0.75rem;
  padding: 1px 6px;
  cursor: pointer;
  margin-left: 0.7em;
  display: inline-block;
  vertical-align: middle;
}
.coauthor-note {
  font-size: 0.75rem;
  font-weight: normal;
}
</style>
<script>
function toggleAbstract(btn) {
  const box = btn.nextElementSibling;
  box.style.display = box.style.display === 'block' ? 'none' : 'block';
}
</script>
<section id="tribal-and-forest-governance" class="level2">
<h2 class="anchored" data-anchor-id="tribal-and-forest-governance">Tribal and Forest Governance</h2>
<div style="text-align: left;">
<p><img src="landing page image.jpg" width="300px"></p>
</div>
<p><strong>Property, Power, and Participation: How Land and Political Rights Transform Forest Governance in Tribal India</strong> <span class="coauthor-note">(Dissertation in Progress)</span></p>
</section>
<section id="responses-to-democratic-backsliding" class="level2">
<h2 class="anchored" data-anchor-id="responses-to-democratic-backsliding">Responses to Democratic Backsliding</h2>
<p><img src="cso endorse.jpg" width="300px"></p>
<p><strong>How Discretion Shapes Civil Society–Opposition Party Alliances Against Democratic Backsliding</strong> <span class="coauthor-note">With <a href="https://www.feyaadallie.com/">Feyaad Allie</a> — (Working Paper)</span> <button class="abstract-toggle" onclick="toggleAbstract(this)">Abstract</button></p>
<div class="abstract-box">
<p>Democratic backsliding weakens both civil society organizations (CSOs) and opposition parties. CSOs face repression, funding cuts, and constraints on traditional activism; opposition parties lose local organizational depth and confront skewed electoral competition. These dual constraints create incentives for political collaboration between the two, but also impose costs. Each actor must retain autonomy, preserve its core identity, and maintain credibility with its base. We argue that these actors navigate their mutual vulnerability through a discretionary alliance: a strategic, selective relationship where each seeks support without full alignment. CSOs engage in partisan mobilization but vary their intensity based on whether opposition candidates align with their organizational mission. In turn, opposition parties seek CSOs with community legitimacy and overlapping goals, while remaining cautious about over-identifying with outside actors. We demonstrate this dynamic through two paired, pre-registered conjoint experiments in India. The first, with 730 representatives from 153 CSOs, shows that CSOs temper the intensity of their electoral engagement when candidate profiles diverge from their mandates. The second, with 736 opposition party workers, reveals that parties prefer CSO allies who combine clear partisan signals with embeddedness in strategically important communities. We triangulate these findings with interviews and 62 days of ethnographic shadowing of CSO-party collaboration during a state election campaign in India to demonstrate the dynamics of such collaboration in practice. Together, our results conceptualize the CSO-party relationship under democratic backsliding as a discretionary alliance that is distinct from both disengagement and blind partisanship: initiated due to democratic constraints, shaped by organizational autonomy, and sustained by strategic calibration.</p>
</div>
<p><br></p>
<p><strong>When Civil Society Overreaches: Voter Aversion to Expansive Civil Society Electoral Mobilization</strong> <span class="coauthor-note">With <a href="https://www.feyaadallie.com/">Feyaad Allie</a> — (Working Paper)</span> <button class="abstract-toggle" onclick="toggleAbstract(this)">Abstract</button></p>
<div class="abstract-box">
<p>Under conditions of democratic backsliding, opposition-aligned civil society organizations (CSOs) often enter electoral arenas to preserve democratic norms, protect community rights, and bolster weakened party capacity. To generate electoral impact while maintaining organizational autonomy, CSOs adopt expansive outreach strategies: they mobilize beyond their core constituents, target multiple marginalized communities, and form cross-organizational coalitions backing opposition candidates. Through a pre-registered conjoint experiment with 730 representatives from 153 CSOs in one Indian state, we show that CSOs view themselves as more effective than parties at reaching voters excluded from dominant civil society and ruling-party networks. Ethnographic fieldwork reveals how coalition-based mobilization allows CSOs to scale efforts while sustaining plausible deniability of partisanship. Yet a paired-profile conjoint experiment with 2,368 voters highlights a sharp constraint: voters penalize expansive CSOs, preferring mobilizers who are coethnic, locally embedded, or directly linked to their own community. A third survey experiment with 2,956 voters reveals the mechanism—expansive CSOs are seen as insincere and less likely to deliver material or rights-based benefits. Together, these findings expose a core dilemma: while democratic erosion compels CSOs to act collectively and broadly, voter selectivity narrows the path to effective partisan mobilization.</p>
</div>
<p><br></p>
<p><strong>Integrating Citizen Awareness into the Study of Democratic Backsliding</strong> <span class="coauthor-note">With <a href="(https://alyssaheinze.github.io/"> Alyssa Heinze</a> — (Working Paper)</span> <button class="abstract-toggle" onclick="toggleAbstract(this)">Abstract</button></p>
<div class="abstract-box">
<p>Most research on democratic backsliding focuses on institutional erosion and elite behavior, often assuming that citizens perceive and respond to democratic decline. This paper argues that citizen awareness should be treated as a core component of backsliding itself, especially in local contexts where violations of democratic procedure may be less visible or politically salient. We propose and test two mechanisms that explain weak citizen backlash to local democratic backsliding: (1) limited recognition that backsliding has occurred, and (2) the redirection of political energy toward identity-based struggles that displace institutional concerns. We examine these dynamics through a mixed-methods study of multi-year local election delays in Maharashtra, India. Drawing on over 2,350 voter surveys, 736 opposition party workers, 730 opposition-aligned civil society organizations, and ethnographic fieldwork, we show that while elites clearly distinguish between elected and unelected governance, many voters do not realize their local body is unelected. Caste-based reservation movements dominate local discourse, reframing political grievances around identity rather than democratic procedure. A survey experiment reveals that informing voters of their local body’s unelected status increases democratic concern, reduces identity-based evaluations of governance, and modestly raises willingness to mobilize. These findings underscore the importance of integrating citizen perception into the study of backsliding, and demonstrate how democratic erosion can persist without overt repression or widespread public disengagement.</p>
</div>
</section>
<section id="political-candidacy-and-representation" class="level2">
<h2 class="anchored" data-anchor-id="political-candidacy-and-representation">Political Candidacy and Representation</h2>
<p><img src="pw training.jpg" width="300px"></p>
<p><strong>Brokered Majoritarianism: Turncoat Minority Politicians and Mixed Returns to Ideological Transformation</strong> <span class="coauthor-note">(Working Paper under review)</span> <button class="abstract-toggle" onclick="toggleAbstract(this)">Abstract</button></p>
<div class="abstract-box">
<p>In ethnically diverse democracies, majoritarian parties often incorporate embedded minority leaders to expand their base. While this enables outreach into new constituencies, its impact on ideological transformation remains underexplored. This paper develops the concept of brokered majoritarianism, where parties outsource minority outreach to turncoats—elites who defect from rival parties but retain community networks. These figures deliver votes but compensate for their majoritarian alignment by reinforcing minority identity. I test this in India, where the Bharatiya Janata Party (BJP) has relied on turncoats from lower-caste (SC) and Indigenous (ST) backgrounds. A vignette experiment with 1,570 SC and ST voters shows that when a co-ethnic BJP politician is a turncoat, they are seen as more powerful than the party and expected to prioritize co-ethnic interests over majoritarian goals. A case study and a visual conjoint experiment in an Indigenous constituency reveal that turncoats dominate party–voter linkage, and compensate Hindu nationalism by amplifying Indigenous identity amongst the base. Brokered majoritarianism thus explains how majoritarian parties can expand electorally while remaining ideologically constrained, decoupling voter alignment from ideological transformation, where minority ethnic identity persists amid all-encompassing majoritarian projects.</p>
</div>
<p><br></p>
<p><strong>Aspirational Tolerance: Political Ambition And Tolerance of Dynastic Politicians</strong> <span class="coauthor-note">With <a href="(https://cprindia.org/people/rahul-verma/">Rahul Verma</a> — (Working Paper under review)</span> <button class="abstract-toggle" onclick="toggleAbstract(this)">Abstract</button></p>
<div class="abstract-box">
<p>Dynastic politicians are ubiquitous in developing democracies, even as voters often express disfavor toward them. Existing literature largely frames dynasticism as an elite-driven, supply-side phenomenon, emphasizing political networks and patronage in explaining the persistence of dynasticism. This paper introduces aspirational tolerance, a demand-side mechanism, where citizens with ambition to enter politics may accept dynasts as a fact of political life, explaining the lack of backlash towards them. Drawing on a nationally representative survey of 1,988 citizens in India, we find that those with nascent ambition to run for office themselves perceive dynastic politicians as having greater capacity than non-dynasts across five key metrics: constituency development, constituency contact, vote-buying, elite contact, and public speaking. Through interviews with electorally ambitious voters, we find evidence of growing tolerance and justification of dynastic politicians. To corroborate, we replicate the survey among a pool of electorally ambitious individuals—736 party representatives across three major political parties in the state of Maharashtra, whom we find to be more likely to have moderated views towards dynasts than ordinary citizens. These findings suggest that electoral ambition fosters aspirational tolerance, where those with hopes of running for office moderate their perceptions of dynastic politicians who occupy dominant roles within parties, limiting backlash against dynasts. Taken together, we offer a demand-driven explanation for the persistence of dynastic politics in developing democracies.</p>
</div>
<p><br></p>
<p><strong>Ambition and Ascent: How Formal Positions Shape Party Worker Attitudes</strong> <span class="coauthor-note">With <a href="https://www.feyaadallie.com/">Feyaad Allie</a> and <a href="https://cprindia.org/people/rahul-verma/">Rahul Verma</a> — (Working Paper)</span> <button class="abstract-toggle" onclick="toggleAbstract(this)">Abstract</button></p>
<div class="abstract-box">
<p>Hierarchical structures are central to how political parties function, yet we know little about how they shape the aspirations, perceptions, and preferences of party workers themselves. This research note analyzes how holding an official role within a party’s local hierarchy—at the booth, block, or district level—shapes political ambition, outlook on internal advancement, and attitudes toward intra-party reforms. Drawing on original survey data from 723 party workers across India and 736 workers in Maharashtra, we show that official position-holders are significantly more likely to express ambition to contest elections, expect to be promoted, and report satisfaction with their political contribution. These individuals also demonstrate stronger support for status quo nomination practices, including elite control over ticket distribution and the role of money in candidacy. At the same time, they are more resistant to democratizing reforms such as internal primaries or eliminating nomination fees. These patterns suggest that internal hierarchies do not simply distribute organizational tasks—they shape how workers interpret their political futures and the legitimacy of internal change. By cultivating ambition and loyalty while embedding resistance to procedural reform, party hierarchies help sustain elite control not only from the top down, but also through incentives and beliefs reinforced from within.</p>
</div>
<p><br></p>
<p><strong>Disproportionate Vacancy: How Bias and Selective Mobilization Shape Vacancies in India’s Village Councils</strong> <span class="coauthor-note">With <a href="https://alyssaheinze.github.io/">Alyssa Heinze</a> — (Work in Progress)</span> <button class="abstract-toggle" onclick="toggleAbstract(this)">Abstract</button></p>
<div class="abstract-box">
<p>Through an original administrative dataset of all vacancies in Maharashtra’s rural government councils, phone surveys of 1400 rural government councils, and a survey experiment with 2950 citizens, we unpack how and why seats reserved for Scheduled Tribes (STs) and in particular ST women, remain grossly over-represented in vacant village council seats.</p>
</div>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>