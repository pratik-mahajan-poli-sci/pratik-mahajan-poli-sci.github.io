<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.549">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Pratik Mahajan - Research</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">Pratik Mahajan</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="./index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link active" href="./research.html" aria-current="page"> 
<span class="menu-text">Research</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./teaching.html"> 
<span class="menu-text">Teaching</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./data.html"> 
<span class="menu-text">Data</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./public writing.html"> 
<span class="menu-text">Public Writing</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./snapshots.html"> 
<span class="menu-text">Fieldwork</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
          <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-full page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content column-page" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Research</h1>
</div>



<div class="quarto-title-meta column-page">

    
  
    
  </div>
  


</header>


<style>
.paper{margin:.75rem 0}
.abstract-box{display:none;max-height:220px;overflow-y:auto;padding:10px;background:#f9f9f9;border-left:4px solid #ccc;margin-left:.5em;font-size:.85rem;width:100%}
button.abstract-toggle{font-size:.75rem;padding:1px 6px;cursor:pointer;margin-left:.7em;display:inline-block;vertical-align:middle}
.coauthor-note{font-size:.75rem;font-weight:normal}
</style>
<script>
document.addEventListener('click', function(e){
  if(e.target.matches('button.abstract-toggle')){
    const paper = e.target.closest('.paper');
    const box = paper && paper.querySelector('.abstract-box');
    if(box){ box.style.display = box.style.display === 'block' ? 'none' : 'block'; }
  }
});
</script>

<section id="tribal-and-forest-governance" class="level2">
<h2 class="anchored" data-anchor-id="tribal-and-forest-governance">Tribal and Forest Governance</h2>
<p><img src="files/landing page image.jpg" width="300px"></p>
<p><strong>Property, Power, and Participation: How Land and Political Rights Transform Forest Governance in Tribal India</strong> <span class="coauthor-note">(Dissertation in Progress)</span></p>
</section>
<section id="political-intermediaries" class="level2">
<h2 class="anchored" data-anchor-id="political-intermediaries">Political Intermediaries</h2>
<p><img src="files/cso endorse.jpg" width="300px"></p>
<div class="paper">
<strong>Brokered Majoritarianism: Turncoat Minority Politicians and Mixed Returns to Ideological Transformation</strong> <span class="coauthor-note">(Working Paper under review)</span> <button class="abstract-toggle">Abstract</button>
<div class="abstract-box">
<p>In ethnically diverse democracies, majoritarian parties often incorporate embedded minority leaders to expand their base. While this enables outreach into new constituencies, its impact on ideological transformation remains underexplored. This paper develops the concept of brokered majoritarianism, where parties outsource minority outreach to turncoats—elites who defect from rival parties but retain community networks. These figures deliver votes but compensate for their majoritarian alignment by reinforcing minority identity. I test this in India, where the Bharatiya Janata Party (BJP) has relied on turncoats from lower-caste (SC) and Indigenous (ST) backgrounds. A vignette experiment with 1,570 SC and ST voters shows that when a co-ethnic BJP politician is a turncoat, they are seen as more powerful than the party and expected to prioritize co-ethnic interests over majoritarian goals. A case study and a visual conjoint experiment in an Indigenous constituency reveal that turncoats dominate party–voter linkage, and compensate Hindu nationalism by amplifying Indigenous identity amongst the base. Brokered majoritarianism thus explains how majoritarian parties can expand electorally while remaining ideologically constrained, decoupling voter alignment from ideological transformation, where minority ethnic identity persists amid all-encompassing majoritarian projects.</p>
</div>
</div>
<div class="paper">
<strong>How Discretion Shapes Intermediary Linkages Between Political Parties and Civil Society Organizations</strong> <span class="coauthor-note">With <a href="https://www.feyaadallie.com/">Feyaad Allie</a> - (Working Paper)</span> <button class="abstract-toggle">Abstract</button>
<div class="abstract-box">
<p>In some contexts, civil society organizations (CSOs) without prior partisan ties form alliances with political parties and become important electoral intermediaries. These relationships are puzzling: CSO members expect their organizations to retain agency to work on societal issues, while party elites worry about retaining an independent brand among their voters and party workers. We argue that intermediary linkages between such actors can occur because they are alliances. Each side seeks strategic advantages without full alignment. CSOs engage in partisan mobilization but calibrate their intensity depending on whether candidates align with their organizational mission. Parties, in turn, pursue CSOs with community legitimacy and electoral advantages, while remaining cautious about over-identifying with actors outside the party brand. We examine this dynamic through two pre-registered conjoint experiments in India. The first, with 730 representatives from 153 CSOs, shows that CSOs reduce the intensity of electoral engagement when ally-party candidate profiles diverge from their mandates. The second, with 736 party workers, demonstrates that party affiliates engage more intensely with CSO allies who combine clear partisan signals with embeddedness in strategically important communities. We triangulate these findings with interviews and 62 days of ethnographic shadowing of CSO-party collaboration during a state election campaign in India to demonstrate the dynamics of such collaboration in practice. Together, the results conceptualize CSO–party relations as discretionary alliances, distinct from both disengagement and blind partisanship: initiated for strategic benefit, constrained by organizational autonomy, and sustained through selective calibration.</p>
</div>
</div>
<div class="paper">
<strong>When Civil Society Overreaches: Voter Aversion to Expansive Civil Society Electoral Mobilization</strong> <span class="coauthor-note">With <a href="https://www.feyaadallie.com/">Feyaad Allie</a> — (Working Paper)</span> <button class="abstract-toggle">Abstract</button>
<div class="abstract-box">
<p>When civil society organizations (CSOs) engage in partisan mobilization, they are most effective with core voters to whom they are directly connected. Yet across contexts, CSOs often pursue expansive mobilization, reaching beyond their base to engage peripheral voters. Drawing on interviews with CSO representatives and observations of their electoral activity in an Indian state election, we inductively develop a theoretical argument to explain this strategy. We argue that under restrictive civil society conditions, CSOs are incentivized to mobilize expansively, especially through umbrella coalitions, because doing so increases their electoral reach while minimizing internal dissent and shielding them from government pressure. A pre-registered conjoint experiment with 730 representatives from 153 CSOs in India shows that CSOs adopt expansive mobilization across civic and partisan activities, and view themselves as likely to succeed compared to party workers with an expansive set of voters. However, a paired-profile conjoint experiment with 2,368 voters reveals the constraint that voters prefer partisan mobilizations by CSOs over parties only when they are coethnic or have a community connection. A third survey experiment with 2,955 voters demonstrates that expansive partisan CSO mobilization is perceived as insincere and less likely to deliver rights-based benefits. These findings highlight a central challenge for CSOs mobilizing against illiberal incumbents: while restrictive environments push CSOs to act collectively and broadly, voter preferences limit the effectiveness of such expansive outreach.</p>
</div>
</div>
<div class="paper">
<strong>Ambition and Ascent: How Formal Positions Shape Party Worker Attitudes</strong> <span class="coauthor-note">With <a href="https://www.feyaadallie.com/">Feyaad Allie</a> and <a href="https://cprindia.org/people/rahul-verma/">Rahul Verma</a> — (Working Paper)</span> <button class="abstract-toggle">Abstract</button>
<div class="abstract-box">
<p>Hierarchical structures are central to how political parties function, yet we know little about how they shape the aspirations, perceptions, and preferences of party workers themselves. This research note analyzes how holding an official role within a party’s local hierarchy—at the booth, block, or district level—shapes political ambition, outlook on internal advancement, and attitudes toward intra-party reforms. Drawing on original survey data from 723 party workers across India and 736 workers in Maharashtra, we show that official position-holders are significantly more likely to express ambition to contest elections, expect to be promoted, and report satisfaction with their political contribution. These individuals also demonstrate stronger support for status quo nomination practices, including elite control over ticket distribution and the role of money in candidacy. At the same time, they are more resistant to democratizing reforms such as internal primaries or eliminating nomination fees. These patterns suggest that internal hierarchies do not simply distribute organizational tasks—they shape how workers interpret their political futures and the legitimacy of internal change. By cultivating ambition and loyalty while embedding resistance to procedural reform, party hierarchies help sustain elite control not only from the top down, but also through incentives and beliefs reinforced from within.</p>
</div>
</div>
</section>
<section id="political-representation" class="level2">
<h2 class="anchored" data-anchor-id="political-representation">Political Representation</h2>
<p><img src="files/pw training.jpg" width="300px"></p>
<div class="paper">
<strong>Aspirational Tolerance: Political Ambition And Tolerance of Dynastic Politicians</strong> <span class="coauthor-note">With <a href="https://cprindia.org/people/rahul-verma/">Rahul Verma</a> — (Working Paper under review)</span> <button class="abstract-toggle">Abstract</button>
<div class="abstract-box">
<p>Dynastic politicians dominate politics in many democracies, despite evidence that large segments of the public disapprove of inherited political power. Yet we know little about how attitudes toward dynastic politicians vary among those likely to challenge them—citizens with ambition to enter politics and the rank-and-file of parties. One might expect ambitious individuals, especially those aspiring to enter politics or rise within party hierarchies, to resent dynastic dominance as an obstacle to their own advancement. These actors face the greatest costs from closed nomination systems and unequal access to resources, and thus represent the most plausible source of bottom-up backlash. Contrary to this expectation, we introduce the concept of aspirational tolerance to describe a process through which political ambition fosters accommodation rather than resistance to dynasts. Using a nationally representative survey of 1,988 Indian voters, we show that ambitious individuals consistently rate dynastic candidates favorably across a range of political traits, including influence, service delivery, and political skills. We interpret this as a strategic response to unequal opportunity structures: for many aspirants, dynasts are powerful actors who must be engaged, not opposed. We extend this logic to a novel survey of 736 party workers across three major parties in Maharashtra, finding no significant difference in attitudes between rank-and-file workers and those holding formal positions. Qualitative interviews with citizens and party workers reveal how party structures reinforce this convergence, as ambition is disciplined through hierarchical exposure. Rather than resisting inherited power, ambitious actors may learn to accommodate it, providing a non-elite level explanation for dynastic persistence in democratic systems.</p>
</div>
</div>
<div class="paper">
<strong>Integrating Citizen Awareness into the Study of Democratic Backsliding</strong> <span class="coauthor-note">With <a href="https://alyssaheinze.github.io/">Alyssa Heinze</a> — (Working Paper)</span> <button class="abstract-toggle">Abstract</button>
<div class="abstract-box">
<p>Most research on democratic backsliding focuses on institutional erosion and elite behavior, often assuming that citizens perceive and respond to democratic decline. This paper argues that citizen awareness should be treated as a core component of backsliding itself, especially in local contexts where violations of democratic procedure may be less visible or politically salient. We propose and test two mechanisms that explain weak citizen backlash to local democratic backsliding: (1) limited recognition that backsliding has occurred, and (2) the redirection of political energy toward identity-based struggles that displace institutional concerns. We examine these dynamics through a mixed-methods study of multi-year local election delays in Maharashtra, India. Drawing on over 2,350 voter surveys, 736 opposition party workers, 730 opposition-aligned civil society organizations, and ethnographic fieldwork, we show that while elites clearly distinguish between elected and unelected governance, many voters do not realize their local body is unelected. Caste-based reservation movements dominate local discourse, reframing political grievances around identity rather than democratic procedure. A survey experiment reveals that informing voters of their local body’s unelected status increases democratic concern, reduces identity-based evaluations of governance, and modestly raises willingness to mobilize. These findings underscore the importance of integrating citizen perception into the study of backsliding, and demonstrate how democratic erosion can persist without overt repression or widespread public disengagement.</p>
</div>
</div>
<div class="paper">
<strong>Disproportionate Vacancy: How Bias and Selective Mobilization Shape Vacancies in India’s Village Councils</strong> <span class="coauthor-note">With <a href="https://alyssaheinze.github.io/">Alyssa Heinze</a> — (Work in Progress)</span> <button class="abstract-toggle">Abstract</button>
<div class="abstract-box">
<p>Through an original administrative dataset of all vacancies in Maharashtra’s rural government councils, phone surveys of 1400 rural government councils, and a survey experiment with 2950 citizens, we unpack how and why seats reserved for Scheduled Tribes (STs) and in particular ST women, remain grossly over-represented in vacant village council seats.</p>
</div>
</div>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>